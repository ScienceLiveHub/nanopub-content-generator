"""
Command Line Interface for nanopub-content-generator package.

This module provides CLI functionality without requiring a standalone script.
Accessible via:
- nanopub-generate (after pip install)
- python -m nanopub_content_generator.cli
"""

import argparse
import asyncio
import json
import sys
from pathlib import Path
from typing import Dict, Any

from .core import NanopubContentGenerator
from . import __version__, __description__


def create_parser() -> argparse.ArgumentParser:
    """Create the command line argument parser."""
    parser = argparse.ArgumentParser(
        prog='nanopub-generate',
        description=__description__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  nanopub-generate --config config.json
  nanopub-generate --config config.json --output ./results --verbose
  python -m nanopub_content_generator.cli --config config.json

Config file format:
  {
    "nanopub_uris": ["https://w3id.org/np/..."],
    "template": "linkedin_post",
    "model": "llama3:8b",
    "user_instructions": "Focus on practical applications",
    "description": "Content generation task"
  }
        """
    )
    
    parser.add_argument(
        '--config', 
        required=True, 
        type=Path,
        help='Path to JSON configuration file'
    )
    
    parser.add_argument(
        '--output', 
        type=Path,
        default=Path('results'),
        help='Output directory for generated content (default: results/)'
    )
    
    parser.add_argument(
        '--verbose', 
        action='store_true',
        help='Enable verbose output'
    )
    
    parser.add_argument(
        '--version', 
        action='version',
        version=f'%(prog)s {__version__}'
    )
    
    return parser


def load_config(config_path: Path) -> Dict[str, Any]:
    """Load and validate configuration from JSON file."""
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"Configuration file not found: {config_path}")
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON in configuration file: {e}")
    
    # Validate required fields
    required_fields = ['nanopub_uris', 'template']
    missing_fields = [field for field in required_fields if field not in config]
    if missing_fields:
        raise ValueError(f"Missing required fields in config: {missing_fields}")
    
    # Set defaults
    config.setdefault('model', 'llama3:8b')
    config.setdefault('user_instructions', '')
    config.setdefault('description', 'CLI content generation')
    
    return config


async def generate_content(config: Dict[str, Any], verbose: bool = False) -> Dict[str, Any]:
    """Generate content using the provided configuration."""
    if verbose:
        print(f"🚀 Initializing content generator...")
        print(f"📊 Nanopublications: {len(config['nanopub_uris'])}")
        print(f"🎯 Template: {config['template']}")
        print(f"🤖 Model: {config['model']}")
    
    generator = NanopubContentGenerator()
    
    try:
        result = await generator.run_pipeline(
            nanopub_uris=config['nanopub_uris'],
            template_name=config['template'],
            ollama_model=config['model'],
            user_instructions=config['user_instructions'],
            description=config['description']
        )
        
        if verbose:
            print(f"✅ Content generation completed")
            print(f"📄 Template used: {result.get('template_used', 'unknown')}")
            print(f"📊 Nanopubs processed: {result.get('nanopubs_processed', 0)}")
        
        return result
        
    except Exception as e:
        if verbose:
            print(f"❌ Content generation failed: {e}")
        raise


def save_results(result: Dict[str, Any], output_dir: Path, config: Dict[str, Any], verbose: bool = False) -> Path:
    """Save generated content to file."""
    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Determine output filename
    template_name = config['template']
    timestamp = result.get('metadata', {}).get('generated_at', 'unknown')[:19].replace(':', '-')
    output_filename = f"{template_name}_{timestamp}.txt"
    output_path = output_dir / output_filename
    
    # Write content to file
    with open(output_path, 'w', encoding='utf-8') as f:
        # Header
        f.write(f"# {template_name.upper().replace('_', ' ')} CONTENT\n")
        f.write(f"Generated by nanopub-content-generator v{__version__}\n")
        f.write(f"Template: {result.get('template_used', template_name)}\n")
        f.write(f"Generated: {result.get('metadata', {}).get('generated_at', 'unknown')}\n")
        f.write(f"Model: {config['model']}\n")
        f.write("=" * 60 + "\n\n")
        
        # Main content
        f.write(result.get('generated_content', 'No content generated'))
        
        # Citations
        citations = result.get('source_citations', '')
        if citations:
            f.write("\n\n" + "=" * 60 + "\n")
            f.write("SOURCE CITATIONS\n")
            f.write("=" * 60 + "\n\n")
            f.write(citations)
        
        # Metadata
        metadata = result.get('metadata', {})
        if metadata:
            f.write("\n\n" + "=" * 60 + "\n")
            f.write("GENERATION METADATA\n")
            f.write("=" * 60 + "\n\n")
            for key, value in metadata.items():
                f.write(f"{key}: {value}\n")
    
    if verbose:
        file_size = output_path.stat().st_size
        print(f"💾 Content saved to: {output_path}")
        print(f"📏 File size: {file_size:,} bytes")
    
    return output_path


async def async_main(args: argparse.Namespace) -> int:
    """Async main function."""
    try:
        # Load configuration
        if args.verbose:
            print(f"📋 Loading configuration from: {args.config}")
        
        config = load_config(args.config)
        
        # Generate content
        result = await generate_content(config, args.verbose)
        
        # Check for errors
        if "error" in result:
            print(f"❌ Error: {result['error']}", file=sys.stderr)
            return 1
        
        # Save results
        output_path = save_results(result, args.output, config, args.verbose)
        
        # Success message
        print(f"✅ Content generation successful!")
        print(f"📄 Output: {output_path}")
        
        # Show content preview if verbose
        if args.verbose:
            content = result.get('generated_content', '')
            preview_length = min(200, len(content))
            print(f"\n📖 Content Preview ({preview_length} chars):")
            print("-" * 50)
            print(content[:preview_length] + ("..." if len(content) > preview_length else ""))
        
        return 0
        
    except Exception as e:
        print(f"❌ Error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


def main():
    """Main CLI entry point."""
    parser = create_parser()
    args = parser.parse_args()
    
    # Run async main
    try:
        exit_code = asyncio.run(async_main(args))
    except KeyboardInterrupt:
        print("\n🛑 Interrupted by user", file=sys.stderr)
        exit_code = 130
    except Exception as e:
        print(f"❌ Unexpected error: {e}", file=sys.stderr)
        exit_code = 1
    
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
